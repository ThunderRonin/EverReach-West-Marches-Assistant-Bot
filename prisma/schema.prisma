generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int       @id @default(autoincrement())
  discordId String
  guildId   String
  createdAt DateTime  @default(now())
  character Character?
  notes     Note[]
  @@unique([discordId, guildId])
}

model Character {
  id        Int        @id @default(autoincrement())
  userId    Int        @unique
  name      String
  gold      Int        @default(100)
  inventory Inventory[]
  tx        TxLog[]
  auctions  Auction[]  @relation("AuctionSeller")
  wonAuctions Auction[] @relation("AuctionBidder")
  bids      Bid[]
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Item {
  id        Int     @id @default(autoincrement())
  key       String  @unique
  name      String
  baseValue Int
  inventory Inventory[]
  auctions  Auction[]
}

model Inventory {
  id        Int  @id @default(autoincrement())
  charId    Int
  itemId    Int
  qty       Int  @default(0)
  @@unique([charId, itemId])
  character Character @relation(fields: [charId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)
}

model TxLog {
  id        Int      @id @default(autoincrement())
  charId    Int
  type      String   // "BUY" | "TRADE" | "AUCTION_SALE" | "AUCTION_REFUND" | "GRANT"
  payload   String   // JSON string
  createdAt DateTime @default(now())
  character Character @relation(fields: [charId], references: [id], onDelete: Cascade)

  // Indexes for transaction history queries
  @@index([charId, createdAt(sort: Desc)])
  @@index([charId, type])
}

model Trade {
  id          Int      @id @default(autoincrement())
  fromCharId  Int
  toCharId    Int
  // Both sides' offers captured as JSON strings: { items: [{itemId, qty}], gold: number }
  offerFrom   String   // JSON string
  offerTo     String   // JSON string
  status      String   @default("PENDING") // PENDING|CANCELLED|EXECUTED|EXPIRED
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  // Indexes for finding pending trades and cleanup operations
  @@index([fromCharId, status])
  @@index([toCharId, status])
  @@index([status, expiresAt])
}

model Auction {
  id              Int      @id @default(autoincrement())
  sellerId        Int
  itemId          Int
  qty             Int
  minBid          Int
  currentBid      Int?
  currentBidderId Int?
  expiresAt       DateTime
  status          String   @default("OPEN")  // OPEN|SOLD|EXPIRED|CANCELLED
  createdAt       DateTime @default(now())

  seller  Character @relation("AuctionSeller", fields: [sellerId], references: [id], onDelete: Cascade)
  item    Item      @relation(fields: [itemId], references: [id], onDelete: Cascade)
  bidder  Character? @relation("AuctionBidder", fields: [currentBidderId], references: [id])
  bids    Bid[]
  message AuctionMessage?

  // Indexes for finding open/expired auctions and user auctions
  @@index([status, expiresAt])
  @@index([sellerId, status])
  @@index([currentBidderId, status])
}

model Bid {
  id        Int      @id @default(autoincrement())
  auctionId Int
  bidderId  Int
  amount    Int
  createdAt DateTime @default(now())
  auction   Auction  @relation(fields: [auctionId], references: [id], onDelete: Cascade)
  bidder    Character @relation(fields: [bidderId], references: [id], onDelete: Cascade)
}

model AuctionMessage {
  id        Int      @id @default(autoincrement())
  auctionId Int      @unique
  messageId String
  channelId String
  guildId   String
  createdAt DateTime @default(now())
  auction   Auction  @relation(fields: [auctionId], references: [id], onDelete: Cascade)

  // Index for finding messages to update by guild/channel
  @@index([guildId, channelId])
}

model Note {
  id        Int      @id @default(autoincrement())
  userId    Int
  text      String
  // Store embedding as BLOB of Float32
  embedding Bytes?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Index for user's notes with descending creation date
  @@index([userId, createdAt(sort: Desc)])
}
